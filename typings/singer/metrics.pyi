"""
This type stub file was generated by pyright.
"""

'''Utilities for logging and parsing metrics.

A Tap should use this library to log structured messages about the read
operations it makes.

Counter is a general-purpose class that allows you to increment a
"counter"-type metric. You initialize a Counter as a context manager, with
a metric name and a dictionary of tags. The Counter will periodically emit
a metric that indicates the amount by which the counter was incremented
since the last time it reported. For example, to increment a record count
for records from a "users" endpoint, you could do:

    with Counter('record_count', {'endpoint': 'users'}) as counter:
        for record in my_records:
            # Do stuff...
            counter.increment()

Timer is class that allows you to track the timing of operations. Like
Counter, you initialize it as a context manager, with a metric name and a
dictionary of tags. When the context exits, the timer will emit a single
metric that indicates how long it took in seconds. The metric will
automatically include a tag called "status" that is set to "failed" if an
Exception was raised, or "succeeded" otherwise.

    with Timer('http_request_duration', {'endpoint': 'users'}):
        # Make a request, do some things

In order to encourage consistent metric and tag names, this module
provides several functions for creating Counters and Timers for very
commonly used metrics.

  * record_counter - Increments a 'record_count' metric to track number of
    records fetched from a source. Provides an "endpoint" tag.

  * http_request_timer - Emits an 'http_request_duration' metric to time
    HTTP requests. Provides "endpoint" tag.

  * job_timer - Emits a 'job_duration' metric to track time of
    asynchronous jobs. Provides "job_type" tag.

'''
DEFAULT_LOG_INTERVAL = ...
class Status:
    '''Constants for status codes'''
    succeeded = ...
    failed = ...


class Metric:
    '''Constants for metric names'''
    record_count = ...
    job_duration = ...
    http_request_duration = ...


class Tag:
    '''Constants for commonly used tags'''
    endpoint = ...
    job_type = ...
    http_status_code = ...
    status = ...


Point = ...
def log(logger, point): # -> None:
    '''Log a single data point.'''
    ...

class Counter:
    '''Increments a counter metric.

    When you use Counter as a context manager, it will automatically emit
    points for a "counter" metric periodically and also when the context
    exits. The only thing you need to do is initialize the Counter and
    then call increment().

    with singer.metrics.Counter('record_count', {'endpoint': 'users'}) as counter:
       for user in get_users(...):
           # Print out the user
           counter.increment()

    This would print a metric like this:

    {
      "type":   "counter",
      "metric": "record_count",
      "value":   12345,
      "tags": {
        "endpoint": "users",
      }
    }

    '''
    def __init__(self, metric, tags=..., log_interval=...) -> None:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def increment(self, amount=...): # -> None:
        '''Increments value by the specified amount.'''
        ...
    
    def __exit__(self, exc_type, exc_value, traceback): # -> None:
        ...
    


class Timer:
    '''Produces metrics about the duration of operations.

    You use a Timer as a context manager wrapping around some operation.
    When the context exits, the Timer emits a metric that indicates how
    long (in seconds) the operation took.

    It will automatically include a "status" tag that is "failed" if the
    context exits with an Exception or "success" if it exits cleanly. You
    can override this by setting timer.status within the context.

    with singer.metrics.Timer('request_duration', {'endpoint': 'users'}):
       # Do some stuff

    This produces a metric like this:

    {
      "type": "timer",
      "metric": "request_duration",
      "value": 1.23,
      "tags": {
        "endpoint": "users",
        "status": "success"
      }
    },

    '''
    def __init__(self, metric, tags) -> None:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def elapsed(self): # -> float:
        '''Return elapsed time'''
        ...
    
    def __exit__(self, exc_type, exc_value, traceback): # -> None:
        ...
    


def record_counter(endpoint=..., log_interval=...): # -> Counter:
    '''Use for counting records retrieved from the source.

    with singer.metrics.record_counter(endpoint="users") as counter:
         for record in my_records:
             # Do something with the record
             counter.increment()
    '''
    ...

def http_request_timer(endpoint): # -> Timer:
    '''Use for timing HTTP requests to an endpoint

    with singer.metrics.http_request_timer("users") as timer:
        # Make a request
    '''
    ...

def job_timer(job_type=...): # -> Timer:
    '''Use for timing asynchronous jobs

    with singer.metrics.job_timer(job_type="users") as timer:
         # Make a request
    '''
    ...

def parse(line): # -> Point | None:
    '''Parse a Point from a log line and return it, or None if no data point.'''
    ...

